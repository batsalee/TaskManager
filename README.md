# TaskManager

해야할 일(Task)들을 관리하는(Manage) 프로그램이라는 뜻입니다.<br/>
윈도우 작업관리자(Ctrl + Shift + ESC 입력시 나오는 창)와 같은 이름이기도 합니다.

<img width="80%" src="https://github.com/batsalee/TaskManager/assets/109213754/54374b91-dee3-4d3d-98c1-1ab0d16a655c)](https://github.com/batsalee/TaskManager/assets/109213754/54374b91-dee3-4d3d-98c1-1ab0d16a655c"/>

---

### 주요 기능

1) Task 리스트 자동 생성<br/>
\- **매일 해결해야 할 일**들의 리스트를 자동으로 나열해줍니다.<br/>
\- **요일별 해결해야 할 일**들의 리스트 또한 자동으로 추가됩니다.<br/>
\- **지난날 해결하지 않고 미루어둔 일**들의 리스트 또한 자동으로 추가됩니다.<br/>

2) 간편한 해결<br/>
\- 나열되어 있는 일들 중 해결한 일은 더블클릭으로 목록에서 **제거**할 수 있습니다.<br/>
\- 해야할 일을 변경해야 한다면 우클릭으로 간단히 내용을 **변경**할 수 있습니다.<br/>
\- 기존 일정 외에 해야할 일이 더 생긴다면 내용을 **추가**할 수 있습니다.<br/>
\- 특정 날짜에 해야할 일정을 미리 추가해둔다면 해당 날짜에 리스트에 반영됩니다.<br/>

3) 시각적 효과<br/>
\- 중요도에 따라 일의 목록을 다르게 나타냅니다.<br/>
\- 기본적인 일은 푸른 배경에 흰 글씨로 나타냅니다.<br/>
\- 중요도가 높은 일은 검은 배경에 금색 글씨로 나타냅니다.<br/>
\- 지난날에 해결하지 않고 미뤄둔 일들은 붉은 배경에 회색 글씨로 나타냅니다.<br/>

4) 인터페이스 구성<br/>
\- 시간과 날짜가 표시됩니다.<br/>
\- 해야할 일들의 리스트가 나열됩니다. 리스트가 많다면 스크롤을 하거나 창의 크기를 조절할 수 있습니다.<br/>
\- 버튼을 이용해 할일을 추가하거나 일정을 관리하는 등의 기능도 수행할 수 있습니다.<br/>

---

### 프로젝트 설치 및 실행 방법

1) 프로젝트 설치 방법<br/>
[https://github.com/batsalee/TaskManager](https://github.com/batsalee/TaskManager)<br/>
해당 주소에서 Clone해서 .zip파일로 다운로드 받을 수 있습니다.<br/>
.zip파일내에 소스코드와 함께 Release폴더가 있습니다.<br/>

2) 프로젝트 실행 방법<br/>
실행은 Release 폴더만 있으면 가능하며 Release 폴더 내의 TaskManager.exe 파일을 이용해 가능합니다.<br/>
다만 처음 사용한다면 아래의 프로젝트 사용 방법 문단을 먼저 읽고 따라한 후에 TaskManager.exe를 실행하는것이 좋습니다.<br/>

---

### 프로젝트 사용 방법

1) 처음 다운로드를 받았다면?<br/>
처음 다운로드를 받았다면 프로그램 실행 전에 매일 해야할 일들의 목록 및 각 요일별 해야할 일들의 목록을 초기설정합니다.<br/>
처음 설정만 해두면 다음부턴 매일 해야할 일들의 목록이 자동으로 반영됩니다.<br/>

    Release -> Schedule -> fixed\_schedule 경로로 들어가서 everyday.txt 파일 및 각 요일.txt파일에 내용을 반영하고 저장합니다.<br/>
    각 파일에 일정을 작성한다면 매일 프로그램 실행시 리스트에 반영됩니다.<br/>

    중요도가 높은 일의 경우 ★을 붙여주면 높은 우선순위로 표현됩니다.(ex. ★중요한일1)<br/>
    한줄에 여러개의 리스트를 표현하고 싶다면 #으로 구분하면 됩니다.<br/>
    예를들면 아래처럼 작성하고 저장하면됩니다.<br/>
    ```
     #해야할일1 #해야할일2 #★중요한일 #해야할일3
    ```

2) 일정 파일을을 모두 작성했다면?<br/>
TaskManager.exe 파일을 실행하면 됩니다.<br/>
매일 사용하게 되는 프로그램이므로 바탕화면에 바로가기를 만들어 두고 사용하면 편리합니다.<br/>

3) 일을 해결했다면?<br/>
해당 Task를 더블클릭하면 리스트에서 삭제됩니다.<br/>

4) 일을 추가하고 싶다면?<br/>
오른쪽에 할일 추가 버튼을 사용해 할일을 작성한후 엔터를 누르면 해야할 일이 추가됩니다.<br/>

5) 일을 변경하고 싶다면?<br/>
표시된 Task를 우클릭하고 변경할 내용을 작성 후 엔터를 누르면 해당 Task가 변경됩니다.<br/>

6) 특정 일자에 해야할 일이 있다면?<br/>
일정 관리에 해당 날짜 경로로 가서 해당 날짜의 파일을 만들고 일정에 대해 적은 후 저장하면 해당 일자에 내용이 반영됩니다.<br/>

---

### 사용된 기술

\- Qt Quick<br/>
\- C++<br/>

인터페이스를 위해 Qt Quick의 qml을 사용했고 내부 처리를 위해 C++을 사용했습니다.<br/>
C++의 파일입출력을 이용해 일정 파일을 생성하며 읽어와서 이중 List에 넣어 사용했습니다.<br/>
Qt Quick의 qml을 이용해 Frameless Window를 만들고 약간의 Javascript로 날짜 및 시간정보를 획득했고<br/>
ListView등을 이용해 Task들을 나열하여 표현했습니다.<br/>

### 해당 기술들을 사용한 이유

1) C++을 선택한 이유<br/>
우선은 윈도우에서 사용할 프로그램이므로 C++을 선택했습니다.<br/>
또한 개인 일정을 다루는 프로그램이므로 데이터베이스 서버에 업로드하기보다는 개인 PC내에서  파일입출력을 통해 처리하고자 했습니다.<br/>

2) Qt Quick을 선택한 이유<br/>
Qml과 C++을 분리해서 디자인부분과 코드부분을 관리할 수 있으며<br/>
이미 잘 다루는 C++을 기반으로 사용할 수 있기에 디자인 부분을 담당하는 qml만 배우면 된다는 점에서 부담이 적었고<br/>
크로스플랫폼 개발을 경험해보고 싶어서 선택했습니다.<br/>

또한 윈도우 GUI 프로그램을 만들기 위해 많은 정보조사를 했습니다만 아래의 환경들은 해당 이유로 선택지에서 제외되었습니다.<br/>

\- Win32 Api 및 MFC : 성능 중시 분야를 제외하고는 신규 프로젝트보다는 유지보수에 사용되며, 현재는 다소 과거의 개발 환경으로 여겨지는듯 했습니다.<br/>
\- Electron : 실행환경에 거의 영향을 받지 않는다고 볼 수 있는 웹 기반 GUI를 표현한다는 장점이 있었지만 HTML, CSS, JavaScript를 익혀야하므로 현시점에 당장 만들어보기에는 학습량이 배보다 배꼽이 더 커질 수 있는 상황이었기에 다음 기회로 미뤄두기로 했습니다.<br/>
\- nana 및 WinUI3 : C++에는 익숙하지만 GUI 개발환경은 새로 익혀야 하는 입장에서 자료가 너무 적었기에 아쉽게도 후순위로 밀리게 되었습니다.<br/>
\- Winform 및 WPF : 윈도우 프로그램을 만들기에 아주 좋은 선택지였지만 C#은 기초문법정도만 공부했던 상황인지라 Electron과 마찬가지로 학습량의 벽이 있었고, 무엇보다 .NET 환경에서만 작동 가능하다는 점이 Qt의 크로스플랫폼에 밀렸습니다. 다만 WPF는 다음 학습목표로 두고 꼭 배워보고 싶은 목표가 되었습니다.<br/>

---

### 프로젝트 진행 중에 했던 고민들과 해결법들

1) 첫 실행인지 재실행인지 구분<br/>
프로그램을 처음 실행했을 때 오늘 날짜에 해야할 일들을 파일에 추가해줘야 했습니다.<br/>
그런데 만약 프로그램을 종료했다가 재실행한다면 오늘 일정을 또 추가해선 안됐습니다.<br/>
그러므로 이미 한번 실행되었는지 확인할 수 있는 기능이 필요했고 이 과정에서 고민을 많이 했지만<br/>
결국 간단하게 첫 실행시 일정 파일의 마지막에 # 하나를 추가하고 재실행시 확인하는 방법으로 해결했습니다.<br/>

2) 지난날 해결하지 않은 일들을 추가하는 방법<br/>
만약 해결하지 않은 일이 있는 상황에서 프로그램을 종료한다면 다음날 해당 일들이 오늘의 일정 밑에 추가되도록 만들고자 했습니다.<br/>
그 방법을 고민하던 중 어제 하지 않은 일들을 저장할 yesterday.txt 파일을 만들고 해당 파일에 해결하지 않은 일들을 저장하고 다음날 추가하고자 했으나, 같은 날에도 프로그램을 종료 후 재실행시 해당 내용이 추가되는 등의 문제가 발생했습니다.<br/>
그렇다보니 yesterday.txt파일을 오늘 날짜의 파일과 같게 계속 갱신해주며, 또한 1번 항목과 같게 오늘 일정 파일에 #이 붙어있다면 yesterday.txt가 이미 append 되어있다는 뜻으로 사용하게 되었습니다.<br/>

3) 화면의 공간을 많이 차지하면 안된다.<br/>
화면의 한 켠에 켜두고 사용하는 빈도가 높은 프로그램입니다.<br/>
그렇다보니 화면의 많은 공간을 차지하면 안되므로 불필요한 제목표시줄 등을 없애고자 했고 Frameless 윈도우로 변경했습니다.<br/>

    하지만 윈도우에서 제공하는 Frame은 단지 제목만 표시하는것이 아니라 다양한 기능들을 제공해주는데 Frameless로 설정시 해당 기능들도 모두 사용할 수 없게 되었습니다.<br/>
    따라서 해당 기능들을 모두 직접 구현해서 인터페이스안에 잘 반영하여 창의 크기 조절과 위치 이동 등의 Frame이 제공하는 기능들의 사용 또한 가능하도록 추가해야 했습니다.<br/>

    그 과정에서 최소화, 최대화, 종료버튼 뿐 아니라 드래그해서 창의 크기를 조절할 수 있는 MouseArea와, 시간 및 날짜가 표시되어 있는 TitleBar를 클릭해서 드래그하면 창을 옮길 수 있어햐 했고, 또한 창을 옮기는 과정에서 x, y좌표가 계산되는 속도가 마우스의 움직임보다 느려서 jiggle현상이 발생했는데 이점을 qml이 아닌 C++로 커서 위치를 얻어와서 해결하는 등 많은 기능을 추가해야 했습니다.<br/>
    이 과정에서 윈도우 운영체제가 기본제공하고 있는 성능들이 당연한것이 아닌 아주 많은 노력이 들어간 잘 만들어진 프로그램이었음을 알게 되었음과 동시에 Qt Quick 프로그램 개발에 대한 경험이 많이 쌓이게 된 부분이었습니다.<br/>
    관련 내용 : [https://stackoverflow.com/questions/18927534/qtquick2-dragging-frameless-window](https://stackoverflow.com/questions/18927534/qtquick2-dragging-frameless-window)<br/>

    또한 많은 창을 띄워두고 작업하는 경우에는 윈도우 작업표시줄을 숨겨두는 경우가 많았습니다.<br/>
    그렇다보니 오늘의 날짜나 시간을 확인하는 경우에 작업표시줄을 확인하게 되는 경우가 많았고, 또한 오늘의 일정을 표시하는 프로그램인 만큼 시간과 날짜를 프로그램에 표시하는것이 좋다고 생각해 사실상 윈도우의 제목표시줄에 해당하는 부분을 시간 및 날짜 표시용도로 사용하게 되었습니다.<br/>

4) 일정이 아주 많다면 화면내에 다 표시할 수 없다.<br/>
처음에는 Window내에 Rectangle을 만들고 그 안에 배경 색깔정도로만 처리한 후 일정들을 표시했었습니다.<br/>
하지만 일정이 아주 많다면 화면안에 표시할 수 없었고, 해당 경우에는 스크롤해서 일정들을 확인한다거나, 창의 크기를 키워서 더 많은 정보를 표시해야 했습니다.<br/>
그러므로 스크롤이 가능한 ListView로 컴포넌트를 변경해서 다시 만들게 되었습니다.<br/>

5) 리스트 삭제시 qml에서의 표현문제<br/>
이중리스트에 해야할 일들이 저장되어 있고 해당 내용들이 qml에 ListView로 표현되어 있습니다.<br/>
그런데 만약 이중 리스트 하위의 리스트에 Task가 1개 있었고, 이 Task를 더블클릭해서 지우게 되면 해당 리스트의 아래에 있는 리스트들은 한칸씩 위로 당겨올라와지게 표현해야 했습니다.<br/>

    이를 위해 단지 Task를 visible: false로 숨기기만 해선 안됐고 이중리스트의 내용이 변경될때마다 이벤트를 발생시켜서 ListView가 이중리스트를 다시 get해와서 표현하도록 구성해야 했습니다.<br/>
    그래서 Scheduler 클래스의 insertTask, updateTask, deleteTask 함수들은 taskChanged 이벤트를 발생하도록 하고, qml에서는 Connections를 만들어 값이 변경될때마다 ListView를 다시 불러오게 만들었습니다.<br/>

    하나의 값이 변경되었을 뿐인데 모든 리스트를 다시 불러와야 하는것이 비효율적이라고 생각되었지만 개인의 하루 일정을 다루는 프로그램인 만큼 데이터의 양이 크지 않았으며 이보다 qml의 간결함을 유지하기 좋은 방법은 없다고 판단하여 유지하게 되었습니다.<br/>

6) ListView의 y축 고정<br/>
ListView에 내용이 많아서 스크롤을 내리고 아래쪽에 있는 Task를 더블클릭해서 삭제하면 ListView가 값을 다시 얻어오는 과정에서 ListView가 가장 위로 올라가는 문제가 있었습니다.<br/>
그래서 값을 삭제하고 ListView를 다시 불러온 후 원래의 위치로 조정해주기 위해 contentY 프로퍼티를 사용하게 되었습니다.<br/>

7) Overscrolling 문제<br/>
값이 제거된 후 값을 다시 얻어온 ListView를 한번 클릭해서 focus를 주기 전까진 ListView가 overscrolling되는 현상이 발생했고<br/>
이를 해결하기 위해 ListView에 강제로 포커스를 주기 위해 forceActiveFocus()를 사용해보기도 하고 onContentYChanged 컴포넌트를 사용해보기도 하는등 많은 노력을 해봤지만<br/>
결국 어떤 부분에선 문제가 발생해 스크롤시 경계부분에서 행동을 정할 수 있는 boundsBehavior 프로퍼티를 사용해 문제를 해결했습니다.<br/>

8) Visual Studio와 Qt Creator간의 호환<br/>
먼저 이 프로젝트를 처음 시작할때만해도 Qt Creator를 사용한 개발 경험은 없었고, 학습하는 수준에서만 사용해봤었습니다.<br/>
그렇다보니 C++로 해결할 기능부분은 익숙한 Visual Studio로 먼저 개발을 마친 후 작동에 문제가 없는것을 확인하고 Qt Creator로 옮겨왔습니다<br/>

    하지만 호환 및 언어버전 때문에 몇몇 문제가 발생했습니다.<br/>
    우선 Visual Studio에서는 프로젝트 설정으로 Modern C++인 C++ 20까지 사용이 가능했기에 Chrono 라이브러리를 사용해 시간 및 날짜 정보를 얻어와서 사용하려고 했으나 Qt Creator에서는 C++ 17까지는 문제없이 사용 가능했지만 C++ 20부터는 다소 완벽하게 사용이 불가능한점이 있었습니다.<br/>
    그렇다보니 결국 Qt의 자체 라이브러리로 다시 구현해야 하는 내용들이 발생했습니다.<br/>

    이때 이후로는 모든 개발을 Visual Studio가 아닌 Qt Creator에서 시작해서 끝내게 되었습니다.<br/>

9) Qt Creator의 불친절<br/>
먼저 Schduler 클래스를 완벽하게 구현한 후 qml과 integration을 위해 몇몇 함수를 Q\_INVOKABLE로 설정하려고 했으나 아무리 설정을 바꾸고, connect를 해도 반영이 안됐습니다.<br/>
몇시간째 해결책도 내지 못하고 있다가 그냥 프로젝트 빌드가 아닌 Qmake빌드를 한번 해줬더니 바로 모두 정상적으로 적용이 됐습니다. 빌드의 종류가 여러가지라는 것을 몰랐던 상황에서 틀린것도 없이 많은 시간낭비를 하게됐었습니다.<br/>

    또한 Qml을 모듈화하기 위해 여러개의 qml 파일로 나누게 되었고 문제없이 잘 나누었지만 계속해서 main.qml에서 모듈화된 qml들을 인식하지 못했고 이 또한 문제를 알아차리기까지 시간이 아주 오래걸렸었습니다.<br/>
    문제는 프로젝트의 makefile이라고 할 수 있는 Qmake의 .pro파일에 새로 만든 qml들이 추가되어 있지 않았다는 것이었는데 IDE에서 파일추가를 해서 작성한 파일들인데 프로젝트에 추가는 또 따로 해줘야 한다는점이 당황스러웠습니다. 하지만 .pro파일만 잘 건드려주면 프로젝트에 파일추가는 쉽게 가능했습니다.<br/>

    해당 항목에서 처음 개발을 배우면서부터 사용했던 Visual Studio가 얼마나 대단한 IDE였는지 깨닫게 되었습니다.<br/>

10) 깔끔한 코드와 깔끔한 기능 사이에서의 고민<br/>
프로젝트를 모두 완성했다고 생각하고 실제로 몇일간 사용해보니 이런 기능이 있다면 좋을텐데같은 생각이 계속해서 떠올랐고 하나하나 추가하다보니 기능이 점점 많아지고 깔끔해졌습니다.<br/>
반면 기능이 개선되고 추가될때마다 코드는 길어지고 보기에 깔끔하지는 않아지는것을 보니 단지 깔끔하고 짧은 코드가 좋은 코드는 아니라는 생각을 또 한번 하게 되었습니다.<br/>

11) 릴리즈의 문제<br/>
정말 많은 시행착오 끝에 드디어 프로젝트를 1차버전 수준까지 완성했고, 릴리즈하여 다른 환경 및 다른 사람들이 사용할 수 있게 해서 피드백을 받고 문제점을 해결해보고자 했었습니다.<br/>
그런데 릴리즈로 빌드하고 windeployqt를 이용해 종속파일들도 추가해서 릴리즈를 했는데 다른 노트북에선 실행이 안됐습니다. msvc 설치가 필요하다는 경고가 나타나는게 첫 시작이었습니다.<br/>

    우선 해결의 첫단계는 컴파일러를 msvc가 아닌 MinGW로 변경했고, 다시 릴리즈해보니 다행히 실행은 잘 되었습니다만 특정 기능만 사용이 불가능했습니다.<br/>
    해결의 두번째 단계는 작동하지 않는 기능의 코드들을 유심히 본 결과 PC내의 파일 경로를 사용하는 코드가 있었는데 개발한 컴퓨터의 환경과는 달리 릴리즈된 컴퓨터의 경우는 경로에 한글이 있었고 해당 부분이 의심되어 경로를 유니코드로 인코딩해서 사용하게 만든 후 릴리즈 문제는 해결되었습니다.<br/>

12) 경로에 이어 파일에서의 유니코드 문제<br/>
fstream 라이브러리를 이용해 파일 입출력을 할때 처음에는 그냥 0과 1로 이루어진 데이터이므로 읽을때와 쓸때만 방식이 같다면 문제가 없을거라고 착각했습니다.<br/>
그렇다보니 유니코드로 문자를 처리하려면 추가해줘야 하는 std::ios::binary를 사용하지 않았었습니다.<br/>
하지만 유니코드를 파일에 작성하면 바이트 크기가 달라져서 항상 문장의 끝에 공백이 2칸씩 들어가게 됐고 이유를 알 수 없는 상태로 몇일간 개발을 하다가<br/>
문장 길이가 실제 파일 내용과 다르게 인식된다는것을 눈치채고 binary로 파일을 읽고 쓰게 변경했습니다.<br/>

---

